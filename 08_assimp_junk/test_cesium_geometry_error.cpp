//
// Cesium 3D Tiles Geometry Error Computation
// Originally generated by CLOUDE
//

#include <algorithm>
#include <cmath>
#include <iostream>
#include <limits>
#include <vector>

#include <gtest/gtest.h>

#ifndef M_PI
/** PI definition */
#define M_PI 3.14159265358979323846
/* 3.1415926535897932384626433832795 */
#endif

/*
 * Cesium 3D Tiles Geometry Error Computation
 *
 * Geometry Error Definition:
 * The maximum visual difference (in meters) between the tile's geometry
 * and its parent's geometry. Used to determine when to refine (load children).
 *
 * Key Concepts:
 * - Higher geometric error = coarser representation
 * - Lower geometric error = more detailed representation
 * - Error of 0 = leaf tile (no further refinement needed)
 */

// ============================================================================
// BASIC GEOMETRY ERROR CALCULATIONS
// ============================================================================

class GeometryErrorCalculator {
public:
    // Method 1: Screen Space Error (SSE) based calculation
    // This is the most common method used in Cesium
    static double computeScreenSpaceError(double maxScreenSpaceError, // Target SSE in pixels (typically 16)
                                          double tileWidth,           // Width of tile in meters
                                          double viewportHeight,      // Height of viewport in pixels
                                          double fovy                 // Vertical field of view in radians
    ) {
        // Geometric error = (2 * tileWidth * tan(fovy/2)) / (viewportHeight * SSE)
        double geometricError = (2.0 * tileWidth * std::tan(fovy / 2.0)) / (viewportHeight / maxScreenSpaceError);

        return geometricError;
    }

    // Method 2: Distance-based error
    // Error based on maximum distance from viewer where tile should be shown
    static double computeDistanceBasedError(double viewDistance,       // Maximum view distance in meters
                                            double pixelErrorThreshold // Error threshold in pixels (typically 1-2)
    ) {
        // Simple linear relationship
        return viewDistance * pixelErrorThreshold / 1000.0;
    }

    // Method 3: LOD (Level of Detail) based error
    // Hierarchical error based on tile tree depth
    static double computeLODBasedError(int lodLevel,             // LOD level (0 = root)
                                       double rootError = 1000.0 // Error at root level
    ) {
        // Each level reduces error by half
        return rootError / std::pow(2.0, lodLevel);
    }

    // Method 4: Bounding volume diagonal based error
    static double computeBoundingVolumeError(const double boundingBox[6], // [minX, minY, minZ, maxX, maxY, maxZ]
                                             double errorRatio = 0.5      // Fraction of diagonal to use as error
    ) {
        double dx = boundingBox[3] - boundingBox[0];
        double dy = boundingBox[4] - boundingBox[1];
        double dz = boundingBox[5] - boundingBox[2];

        double diagonal = std::sqrt(dx * dx + dy * dy + dz * dz);

        return diagonal * errorRatio;
    }

    // Method 5: Point cloud density based error
    static double computePointCloudError(int pointCount,              // Number of points in tile
                                         double tileArea,             // Area of tile in square meters
                                         double maxPointSpacing = 1.0 // Maximum acceptable point spacing
    ) {
        // Calculate point density
        double density = pointCount / tileArea;
        double avgSpacing = 1.0 / std::sqrt(density);

        // Error is based on how spacing compares to maximum
        return std::max(0.0, avgSpacing - maxPointSpacing);
    }
};

// ============================================================================
// BOUNDING VOLUME STRUCTURES
// ============================================================================

struct BoundingBox {
    double center[3];
    double halfAxes[3];

    double getDiagonal() const {
        return 2.0 * std::sqrt(halfAxes[0] * halfAxes[0] + halfAxes[1] * halfAxes[1] + halfAxes[2] * halfAxes[2]);
    }
};

struct BoundingSphere {
    double center[3];
    double radius;

    double getDiameter() const { return 2.0 * radius; }
};

struct BoundingRegion {
    double west, south, east, north; // Radians
    double minHeight, maxHeight;     // Meters

    double getMaxDimension() const {
        // Approximate size in meters
        const double EARTH_RADIUS = 6371000.0; // meters

        double latExtent = (north - south) * EARTH_RADIUS;
        double lonExtent = (east - west) * EARTH_RADIUS * std::cos((north + south) / 2.0);
        double heightExtent = maxHeight - minHeight;

        return std::max({latExtent, lonExtent, heightExtent});
    }
};

// ============================================================================
// PRACTICAL GEOMETRY ERROR CALCULATOR
// ============================================================================

class TileGeometryError {
public:
    // Compute geometry error based on tile properties
    static double compute(const BoundingBox &bbox, int lodLevel, int vertexCount,
                          double targetScreenSpaceError = 16.0) {
        // Get tile dimensions
        double diagonal = bbox.getDiagonal();

        // Base error from bounding volume
        double baseError = diagonal * 0.5;

        // Adjust based on LOD level
        double lodFactor = 1.0 / std::pow(2.0, lodLevel);

        // Adjust based on complexity (vertex count)
        double complexityFactor = 1.0;
        if (vertexCount > 0) {
            // More vertices = lower error tolerance
            complexityFactor = std::max(0.1, 1000.0 / vertexCount);
        }

        return baseError * lodFactor * complexityFactor;
    }

    // Compute error for point cloud tile
    static double computeForPointCloud(const BoundingSphere &sphere, int pointCount, int lodLevel) {
        // Base error from bounding sphere
        double baseError = sphere.radius;

        // Adjust for LOD
        double lodFactor = 1.0 / std::pow(2.0, lodLevel);

        // Adjust for point density
        double densityFactor = 1.0;
        if (pointCount > 0) {
            // Estimate point spacing
            double volume = (4.0 / 3.0) * M_PI * sphere.radius * sphere.radius * sphere.radius;
            double avgSpacing = std::cbrt(volume / pointCount);
            densityFactor = avgSpacing / sphere.radius;
        }

        return baseError * lodFactor * densityFactor;
    }

    // Compute error for region-based tile (terrain)
    static double computeForTerrain(const BoundingRegion &region, int lodLevel,
                                    double heightError = 0.0 // Maximum vertical error from simplification
    ) {
        // Get horizontal extent
        double maxExtent = region.getMaxDimension();

        // Base error
        double baseError = maxExtent * 0.1;

        // Adjust for LOD
        double lodFactor = 1.0 / std::pow(2.0, lodLevel);

        // Include height error if specified
        if (heightError > 0.0) {
            baseError = std::max(baseError, heightError * 2.0);
        }

        return baseError * lodFactor;
    }
};

// ============================================================================
// TILESET.JSON GEOMETRY ERROR MANAGEMENT
// ============================================================================

class TilesetGeometryError {
public:
    struct TileInfo {
        std::string uri;
        double geometricError;
        int lodLevel;
        BoundingBox boundingBox;
        std::vector<TileInfo> children;
    };

    // Build hierarchical error values for tileset
    static void computeHierarchicalErrors(TileInfo &rootTile, double rootError = 1000.0) {
        computeHierarchicalErrorsRecursive(rootTile, rootError, 0);
    }

    // Validate that errors decrease monotonically down the tree
    static bool validateErrorHierarchy(const TileInfo &tile) {
        for (const auto &child : tile.children) {
            if (child.geometricError >= tile.geometricError) {
                std::cerr << "Error: Child error (" << child.geometricError << ") >= parent error ("
                          << tile.geometricError << ")\n";
                return false;
            }

            if (!validateErrorHierarchy(child)) {
                return false;
            }
        }
        return true;
    }

    // Recommend error value based on tile properties
    static double recommendError(double parentError, const BoundingBox &bbox, int childCount,
                                 double refinementRatio = 0.5 // Typical: 0.5 (half of parent)
    ) {
        // Start with refinement ratio of parent
        double recommendedError = parentError * refinementRatio;

        // Ensure error is reasonable for tile size
        double diagonal = bbox.getDiagonal();
        double maxError = diagonal * 0.5;
        double minError = diagonal * 0.01;

        recommendedError = std::clamp(recommendedError, minError, maxError);

        return recommendedError;
    }

private:
    static void computeHierarchicalErrorsRecursive(TileInfo &tile, double parentError, int level) {
        // Set this tile's error
        tile.geometricError = parentError;
        tile.lodLevel = level;

        // Compute child errors (typically half of parent)
        double childError = parentError * 0.5;

        for (auto &child : tile.children) {
            computeHierarchicalErrorsRecursive(child, childError, level + 1);
        }

        // Leaf tiles should have error of 0
        if (tile.children.empty()) {
            tile.geometricError = 0.0;
        }
    }
};

// ============================================================================
// PRACTICAL USAGE EXAMPLES
// ============================================================================

void demonstrateGeometryErrorCalculations() {
    std::cout << "=== Cesium 3D Tiles Geometry Error Calculations ===\n\n";

    // Example 1: Screen Space Error calculation
    std::cout << "Example 1: Screen Space Error Method\n";
    {
        double tileWidth = 100.0;          // meters
        double viewportHeight = 1080.0;    // pixels
        double fovy = 60.0 * M_PI / 180.0; // radians
        double maxSSE = 16.0;              // pixels

        double error = GeometryErrorCalculator::computeScreenSpaceError(maxSSE, tileWidth, viewportHeight, fovy);

        std::cout << "  Tile width: " << tileWidth << " m\n";
        std::cout << "  Viewport: " << viewportHeight << " px\n";
        std::cout << "  FOV: " << (fovy * 180.0 / M_PI) << " degrees\n";
        std::cout << "  Target SSE: " << maxSSE << " px\n";
        std::cout << "  Computed Geometric Error: " << error << " m\n\n";
    }

    // Example 2: LOD-based hierarchy
    std::cout << "Example 2: LOD-Based Hierarchy\n";
    {
        double rootError = 1000.0;

        std::cout << "  LOD Level | Geometric Error\n";
        std::cout << "  ----------|----------------\n";

        for (int lod = 0; lod <= 5; ++lod) {
            double error = GeometryErrorCalculator::computeLODBasedError(lod, rootError);
            printf("  %9d | %14.2f m\n", lod, error);
        }
        std::cout << "\n";
    }

    // Example 3: Bounding box based
    std::cout << "Example 3: Bounding Volume Method\n";
    {
        double bbox[6] = {0, 0, 0, 100, 100, 50}; // 100x100x50 meter box

        double error = GeometryErrorCalculator::computeBoundingVolumeError(bbox, 0.5);

        std::cout << "  Bounding box: 100x100x50 m\n";
        std::cout << "  Computed Geometric Error: " << error << " m\n\n";
    }

    // Example 4: Point cloud
    std::cout << "Example 4: Point Cloud Method\n";
    {
        BoundingSphere sphere = {{0, 0, 0}, 50.0}; // 50m radius
        int pointCount = 1000000;
        int lodLevel = 2;

        double error = TileGeometryError::computeForPointCloud(sphere, pointCount, lodLevel);

        std::cout << "  Bounding sphere radius: " << sphere.radius << " m\n";
        std::cout << "  Point count: " << pointCount << "\n";
        std::cout << "  LOD level: " << lodLevel << "\n";
        std::cout << "  Computed Geometric Error: " << error << " m\n\n";
    }

    // Example 5: Typical values for different content types
    std::cout << "Example 5: Typical Geometric Error Values\n";
    std::cout << "  Content Type          | Root Error | Leaf Error\n";
    std::cout << "  ----------------------|------------|------------\n";
    std::cout << "  Building Models       |  1000.0 m  |    0.0 m\n";
    std::cout << "  Terrain (high res)    |   500.0 m  |    0.5 m\n";
    std::cout << "  Point Cloud (city)    |   100.0 m  |    1.0 m\n";
    std::cout << "  Photogrammetry        |   200.0 m  |    0.1 m\n";
    std::cout << "  Instanced Models      |  5000.0 m  |    0.0 m\n\n";

    // Example 6: Error validation
    std::cout << "Example 6: Hierarchy Validation\n";
    {
        TilesetGeometryError::TileInfo root;
        root.geometricError = 1000.0;

        TilesetGeometryError::TileInfo child1, child2;
        child1.geometricError = 500.0;
        child2.geometricError = 450.0;

        root.children.push_back(child1);
        root.children.push_back(child2);

        bool valid = TilesetGeometryError::validateErrorHierarchy(root);
        std::cout << "  Hierarchy valid: " << (valid ? "YES" : "NO") << "\n\n";
    }
}

class CesiumF : public testing::Test {};

/// @brief demonstrate Geometry Error Calculations
/// @param --gtest_filter=CesiumF.demonstrateGeometryErrorCalculations
/// @param
TEST_F(CesiumF, demonstrateGeometryErrorCalculations) {
    demonstrateGeometryErrorCalculations();

    std::cout << "=== Key Guidelines for Geometry Error ===\n\n";
    std::cout << "1. Parent error must be GREATER than child error\n";
    std::cout << "2. Leaf tiles should have error = 0\n";
    std::cout << "3. Typical refinement ratio: 0.5 (child = 0.5 * parent)\n";
    std::cout << "4. Common SSE target: 16 pixels\n";
    std::cout << "5. Root error typically: 100-5000 meters (depends on content)\n";
    std::cout << "6. Error determines view distance for tile rendering\n";
    std::cout << "7. Lower error = more detailed, loaded closer to camera\n";
    std::cout << "8. Higher error = less detailed, visible from farther away\n";
}